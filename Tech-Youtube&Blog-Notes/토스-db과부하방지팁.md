# [토스]DB과부하 방지 팁 
24.03.07

## 읽으면서 모르는거 기록
- db시스템은 확장을 하기 어렵다는데 왜?
- CAP이론 읽어보자. https://www.ibm.com/kr-ko/topics/cap-theorem
- 가급적 디비의 부하를 최소화해서 확장 필요성 줄이는게 바람직. 이를 위해 **캐시**(레디스, 멤캐시드)를 이용!
- 높은 캐시 히트율통한 트래픽처리시 db에 부담을 줄임. 
- 캐시가 동시에 다량으로 만료되도록 설계하면 만료가 되고 캐시 쇄도(cache stampede)라고하는 캐시 미스가 대량으로 발생함으로서 db에 부담이 될수있음 
	- 해결방법: 지터(Jitter)사용. 캐시 만료 시간을 무작위로 지연시키는 방법. 지터=짧은 지연 시간
- 캐시에서 null이 반환되어 db서버에서 조회를 했는데도 null이 반환되었는데 이를 캐시 안하도록 구현하는 경우가 흔하다함. null도 값이 없다라는 정보임. 이런 상황을 캐시 관통(cache penetration)이라함. 이러면 db에 불필요한 쿼리요청 계혹 발생함. 캐시를 미들웨어로 두었는데도 부하 분담을 안해주는 상황
	- 해결방법: Null Object Pattern을 사용. 검색해보니 구현방법이 다양하다. null을 처리하는 정책을 수립하는것이라 이해되는데...
- 블룸 필터가 뭐지?
- 캐시 시스템이 장애가 났을때는 어떻게하지?
	- 해결방법: 대체 작동(Failover), 핵심 서비스 기능과 그 외 기능을 구별해서 핵심 서비스만 일단 동작하도록 하기. 캐시 없는 db가 트래픽을 다 처리할수 있을지 어떻게 확신할 수 있겟는가? 이런 상황도 가정해서 서비스의 기능들을 분류해놓는게 현명할듯함.
- 핫키란 많은 요청이 집중되는 키
- 핫키가 만료되는 그 순간에 여러 요청이 올수 있다(블로그에 있는 그림을 보면 더 확실히 상황이해가 가능하다). 이를 방지 하려면 만료 기한을 없애거나, 백그라운드에서 주기적으로 새 값을 갱신하여 만료 안되게할 수 있지만, 핫키가 상황에 따라 바뀌는 환경에서는 더 이상 핫키가아닌 키를 위해 이런일을 하여 리소스를 낭비 할 수 있다.
	- 해결방법: 분산 락(distributed lock), 캐시를 애플리케이션 서버간 공유자원으로 바라볼 수있다. 캐시 미스가 발생했을때 락을 걸고 캐싱후 락을 해재함으로써, 단 한번의 캐시 쓰기만 하면 되는것.
- 레디스는 분산 락 적용이 쉽다. 레디스의 싱글 스레드 특징을 활용한 레드락 알고리즘 덕분. 레드락 알고리즘 알아보기!
## Reference
https://toss.tech/article/cache-traffic-tip
