# 메모리 가시성이란?

메모리 가시성(Memory Visibility)은 멀티스레딩 환경에서 한 스레드가 메모리에 기록한 변경 사항이 다른 스레드에게 언제, 어떻게 보이는지를 의미합니다. 이는 주로 컴퓨터 과학에서 동시성 문제를 다룰 때 중요한 개념입니다. 메모리 가시성 문제는 여러 스레드가 공유 자원에 접근할 때 발생할 수 있으며, 적절한 동기화 없이 스레드 간에 데이터 일관성을 보장하기 어려운 상황이 발생할 수 있습니다.

### 메모리 가시성 문제의 원인
1. **CPU 캐시**: 각 CPU 코어는 성능 향상을 위해 자신의 캐시를 사용합니다. 한 코어가 메모리를 변경해도 다른 코어는 자신의 캐시된 값을 참조할 수 있어 변경 사항이 즉시 반영되지 않을 수 있습니다.
2. **컴파일러 최적화**: 컴파일러는 코드의 성능을 최적화하기 위해 변수의 값을 레지스터에 저장하거나, 불필요한 메모리 접근을 제거하는 등의 최적화를 수행합니다. 이로 인해 예상치 못한 메모리 가시성 문제가 발생할 수 있습니다.
3. **메모리 재정렬 (Memory Reordering)**: 프로세서나 컴파일러가 명령어의 순서를 변경하여 성능을 최적화하는데, 이는 메모리 접근 순서에 영향을 미쳐 가시성 문제를 유발할 수 있습니다.

### 메모리 가시성 보장 방법
1. **동기화 메커니즘 사용**: 
    - **뮤텍스(Mutex)와 락(Lock)**: 상호 배제 동기화 메커니즘을 사용하여 한 번에 하나의 스레드만 공유 자원에 접근하도록 합니다.
    - **조건 변수(Condition Variables)**: 특정 조건이 만족될 때까지 스레드를 기다리게 하거나 조건이 만족되면 스레드를 깨워주는 동기화 도구입니다.

2. **메모리 배리어 (Memory Barriers) / 펜스(Fence)**:
    - **메모리 배리어**: 프로세서에게 특정 명령어 이전의 모든 메모리 연산이 완료된 후에야 다음 명령어를 실행하도록 지시합니다. 이는 명령어 재정렬을 방지하고 메모리 가시성을 보장합니다.
    
3. **언어 수준의 동기화 도구**:
    - **자바의 volatile 키워드**: 변수를 volatile로 선언하면 해당 변수에 대한 읽기와 쓰기가 직접 메모리에서 이루어져 캐시의 일관성 문제를 방지합니다.
    - **C++의 std::atomic**: 원자적 연산을 제공하여 변수에 대한 동기화된 접근을 보장합니다.

### 예시
```java
class SharedObject {
    private volatile boolean flag = false;

    public void writerThread() {
        flag = true; // 이 쓰레드가 flag를 true로 설정
    }

    public void readerThread() {
        while (!flag) {
            // flag가 true가 될 때까지 대기
        }
        // flag가 true가 되면 실행
    }
}
```
위 예시에서 `volatile` 키워드는 `flag` 변수에 대한 메모리 가시성을 보장합니다. `writerThread`가 `flag`를 `true`로 설정하면, 다른 모든 스레드에서 이 변경 사항을 즉시 볼 수 있습니다.

메모리 가시성 문제를 해결하려면 이러한 동기화 기법과 언어적 지원을 적절히 활용해야 합니다. 이를 통해 멀티스레드 환경에서 데이터의 일관성과 정확성을 유지할 수 있습니다.

by chatGPT 4o